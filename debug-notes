May 8
=====

I have a number of things working nicely with C::Blocks. One thing that is not
working is shared symbol tables, as demonstrated with the simple test called
05-shared.t

The problem in that test is that I get a segfault. The segfault does not occur
during compilation, but during runtime. This is rather odd. Preliminary
investigation has revealed that the compiler is *not* looking up symbols in the
extended symbol tables, so I would have expected to get a number of compilation
errors. Furthermore, the test shows that the segfault occurs even before the
first printf can display its message.

Here's the first interesting bit: if I comment-out the call to the function
defined in the clex block, it runs without segfaulting. Since this might be
some issue with defaulting to a signature of int func(int), and since print_ok
does not have that signature, I tried the int-int form and still go segfaults.
This suggests that the presence of the unknown and undeclared symbol print_ok
somehow screws up the pointer accounting in the compilation unit.

A simple test for how easy, or not, it is to cause this complication is to
simply add a call to the (yet undeclared) print_ok function, and see if it
breaks the original block. Apparently it does! This suggests that tcc is making
some assumption about the function for me. Perhaps this can be solved by
setting an appropriate flag.

After digging around, I realized I could use tcc_set_options to set the various
compiler options. The first string that I tried, "-Wall", solved the problem by
warning upon encountering the undeclared printf function. Although it was only
a warning, the error handling system caught the problem because it does not
differentiate between a warning and an error. At some point I need to add more
flexible configuration management. I also need to add a way to link to external
libraries, such as libperl.

The simplest mechanism to handle library linking is to provide a hints hash
mechanism, along with an api to play with the hints hash mechanism. Note that
this need not be through the keywords API. It could be through the use
mechanism, i.e. "use C::Blocks -I => '/usr/inc/', -L => '...', -l => '...';"
For now, I could allow these to accumulate, and I could later add a module for
greater manipulation (i.e. removal of items from the list, for example) or
automation when the time comes.

May 9
=====

Today I will try to implement the pulling-in of libperl. I expect that this
will involve compiling Perl's header files (eventually caching and loading that
to speed things up) and adding the library to the TCCState. This will likely
involve expanding the stream of pointers that gets copied among the hint hash
entries.

May 10
======

I thought quite a bit about how to implement the idea posed above. The problem
is that TCC does not know how to link against libraries on Mac OS, so I need to
use some alternative mechanism to pull in symbols. The simplest approach is to
use Dynaloader to load the library and retrieve symbols as needed. The folder
to include is under "$Config{archlib}/CORE", and libperl is called
"$Config{archlib}/CORE/$Config{libperl}". Dynaloader may only provide a Perlish
interface, but that is C accessible and does not intrinsically make it slow, by
any means.

So, I think I will write a C function that loads a library by calling
Dynaloader, through Perl, and another C function that loads symbols from a
library through Dynaloader, again through Perl. If there are ways to speed up
this process, they can be worked out after the first hack has been achieved.
This approach will work cross platform (even for systems that TCC knows how to
link against) and is a nice starting point.
