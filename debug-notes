May 8
=====

I have a number of things working nicely with C::Blocks. One thing that is not
working is shared symbol tables, as demonstrated with the simple test called
05-shared.t

The problem in that test is that I get a segfault. The segfault does not occur
during compilation, but during runtime. This is rather odd. Preliminary
investigation has revealed that the compiler is *not* looking up symbols in the
extended symbol tables, so I would have expected to get a number of compilation
errors. Furthermore, the test shows that the segfault occurs even before the
first printf can display its message.

Here's the first interesting bit: if I comment-out the call to the function
defined in the clex block, it runs without segfaulting. Since this might be
some issue with defaulting to a signature of int func(int), and since print_ok
does not have that signature, I tried the int-int form and still go segfaults.
This suggests that the presence of the unknown and undeclared symbol print_ok
somehow screws up the pointer accounting in the compilation unit.

A simple test for how easy, or not, it is to cause this complication is to
simply add a call to the (yet undeclared) print_ok function, and see if it
breaks the original block. Apparently it does! This suggests that tcc is making
some assumption about the function for me. Perhaps this can be solved by
setting an appropriate flag.

After digging around, I realized I could use tcc_set_options to set the various
compiler options. The first string that I tried, "-Wall", solved the problem by
warning upon encountering the undeclared printf function. Although it was only
a warning, the error handling system caught the problem because it does not
differentiate between a warning and an error. At some point I need to add more
flexible configuration management. I also need to add a way to link to external
libraries, such as libperl.

The simplest mechanism to handle library linking is to provide a hints hash
mechanism, along with an api to play with the hints hash mechanism. Note that
this need not be through the keywords API. It could be through the use
mechanism, i.e. "use C::Blocks -I => '/usr/inc/', -L => '...', -l => '...';"
For now, I could allow these to accumulate, and I could later add a module for
greater manipulation (i.e. removal of items from the list, for example) or
automation when the time comes.
