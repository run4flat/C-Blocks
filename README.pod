=head1 NAME

C::Blocks - embeding a fast C compiler directly into your Perl parser

=head1 SYNOPSIS

 use strict;
 use warnings;
 use C::Blocks;
 cuse C::Blocks::libperl;
 
 our $global_var = "Before first cblock";
 print "Before the first cblock, \$global_var conains [$global_var]\n";
 
 cblock {
     /* This is raw C code! */
     SV * global = get_sv("global_var", 0);
     sv_setpv(global, "After first cblock");
 }
 
 print "After the first cblock, \$global_var conains [$global_var]\n";

=head1 ALPHA

This project is currently in alpha. Using this software is likely to
cause segmentation faults and the API is likely to change over time.
Basically, if you're not actively developing this code, you should
probably steer clear of it for now.

=head1 DESCRIPTION

This module uses Perl's pluggable keyword API to add a number of new
keywords including C<cblock>, C<cshare>, C<clex>, and C<cuse>.
For all but C<cuse>, the block of code that follows the keyword gets
compiled. Code in a C<cblock> gets inserted into Perl's op-tree and
executed whenever execution of the code arrives at that op. Code in
C<clex> and C<cshare> is compiled and the declarations and definitions
are made available to later C<cblock>, C<clex>, and C<cshare> blocks.

The major contribution that this package has over a similar package
such as 

=head1 DEVELOPMENT BOOTSTRAP

To get started developing on this library, clone the github repository:

 git clone https://github.com/run4flat/C-Blocks.git
 cd C-Blocks
 perl Buil.PL

Presently, F<Build.PL> has a specially written bootstrap that detects
any missing dependencies and offers to install them for you. Once
everything have been installed, hop on to the MagNET's #tinycc channel
and join in the discussion!

=head1 CURRENT STATUS

As of May 21, 2014, the pass/fail matrix is this:

 System \ Test        | 01 | 02 | 03 | 04 | 10 | 12 |
 ----------------------------------------------------
 XP Strawberry 5.18   |  y |  y |  y | #1 | #2 | #5 |
 Mac perlbrew 5.18 sh |  y |  y |  y |  y | #3 | #5 |
 Mac perlbrew 5.18 st |  y |  y |  y | #4 | #3 | #5 |
 Wheezy sys 5.14      |  y |  y |  y |  y | #3 | #5 |

Any failures are enumerated in the table and described below. If
things change, or if you have a new result, please add it to the
table and update the failure descriptions below.

=over

=item 1

On Windows XP running Strawberry Perl 5.18, the very first subtest
of test 04 prints its status:

 ok 1 - Can set Perl data in a cblock using direct function calls

Then Perl crashes.

=item 2

On Windows XP running Strawberry Perl 5.18, for test 10, all cblocks
compile fine, and everything runs fine until I try to execute a
cblock that calls a function that was already called by a previous
cblock. This happens to be the code just after test #14, "sending foo
works". Thereafter, the process crashes.

=item 3

On Mac and Linux, test 10 sometimes displays the following error:

 Internal error: unable to locate extended symbol

Other times, it runs the full test suite, passing all but the last
test. for that test, it always reports some odd mish-mashed string,
certainly not the string that I sent it the first time.

=item 4

On any default-compiled Perlbrew, the generated F<libperl> is a static
library. There is a slim chance that TCC can link against a static
library on Windows and Linux. There is no chance that it can link
against a static library on Mac. Any tests against L<C::Blocks::libperl>
will fail in this situation.

=item 5

All operating systems appear to segfault with test 12 after the 11th
subtest. That subtest is the *second* subtest in which I would actually
manipulate data in an already allocated struct. It appears that the
second time through when actually manipulating things, we get weird
segfaults.

=back

=head1 GOALS

I have a number of goals I would like to accomplish before I push his
out to CPAN. These include

=over

=item Squash all segfaults

I am still encountering a lot of segfaults. I need to figure out what
gives rise to those and plug them.

=item Extended Symbol Table Caching

The current symbol table copying implemented in Alien::TinyCC's copy
of tcc involves an N**2 lookup procedure. For large code bases such
as libperl's, the copy procedure takes on the order of seconds. I
would like to hack on tcc to provide extended symbol table dump and
load functionality to minimize the startup time when using
L<C::Blocks::libperl>.

=item Hash table for extended symbol table lookups

The lookup-by-name is currently implemented by iterating through each
TokenSym and checking if that TokenSym's name matches the bareword of
interest. This could be substantially sped up if I had a hash table
mapping names to TokenSym array offsets.

=item Refactor Blocks.xs

The keyword parser in Blocks.xs is enormous. This needs to be split
into several smaller functions.

=item "Interpolate" sigils

I would like C<$variable> to look up and return the C<SV*>
associated with that variable, either the lexically or the globally
scoped SV. The compiler can be asked at that poin in the parse if
it has seen a lexical variable by that name, so it should be
posible to figure out the correct interpretation (pull from pad
vs pull from symbol table) at C<cblock> compile time.

Furthermore, it shouldn't be too hard to implement. TCC knows how to
detect the C<$> character because it is used in assembly code. I
would like to hack on TCC to treat this like a runtime preprocessor
macro, such that I could write the token stream *during* the C parse
stage. I know enough about token streams to accomplish this.

=item Switch to call_checker and call_parser

The keyword API is so yesterday. I used it for prototyping, but I
need to switch to the new method. That doesn't need to happen before
it hits CPAN, but I would like for it to happen soon.

=item Scrap cuse

I need to come up with a better way of importing code into the
current lexical scope. C<cuse> is doin the job for the moment, but
it kinda sucks and needs to be rethought.

=item Threadsafe

The Tiny C Compiler uses lots of global variables and is therefore not
threadsafe. I would like to contribute back to the project by
encapsulating all of that global state into the compiler state object,
where it belongs. Others in the tcc community have expressed interest in
getting this done, so it is a welcome contribution.

=item Extraction for optimized compiling

Right now the C code gets compiled at Perl's parse time. However, for
code that doesn't change, it would be nice to prototype the code using
C::Blocks, then extract the op-code definitions into an XS file to be
compiled by an optimized compiler (such as gcc). This would require
writing a second pluggable keyword module that takes the same input and
generates XS output instead of compiling the code.

=back

=head1 SEE ALSO

This module uses the Tiny C Compiler through the Alien package provided
by L<Alien::TinyCC>. To learn more about the Tiny C Compiler, see
L<http://bellard.org/tcc/> and L<http://savannah.nongnu.org/projects/tinycc>.

For other ways of compiling C code in your Perl scripts, check out
L<Inline::C>, L<C::TinyCompiler>, and L<XS::TCC>.

=head1 AUTHOR

David Mertens (dcmertens.perl@gmail.com)

=head1 BUGS

Please report any bugs or feature requests for the Alien bindings at the
project's main github page:
L<http://github.com/run4flat/C-Blocks/issues>.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc C::Blocks

You can also look for information at:

=over 4

=item * The Github issue tracker (report bugs here)

L<http://github.com/run4flat/C-Blocks/issues>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/C-Blocks>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/C-Blocks>

=item * Search CPAN

L<http://p3rl.org/C::Blocks>
L<http://search.cpan.org/dist/C-Blocks/>

=back

=head1 ACKNOWLEDGEMENTS

This would not be possible without the amazing Tiny C Compiler or the
Perl pluggable keyword work. My thanks goes out to developers of both of
these amazing pieces of technology.

=head1 LICENSE AND COPYRIGHT

Code copyright 2013 Dickinson College. Documentation copyright 2013 David
Mertens.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut

