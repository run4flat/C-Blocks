=head1 NAME

C::Blocks - embeding a fast C compiler directly into your Perl parser

=head1 SYNOPSIS

 use strict;
 use warnings;
 use C::Blocks;
 cuse C::Blocks::libperl;
 
 our $global_var = "Before first cblock";
 print "Before the first cblock, \$global_var conains [$global_var]\n";
 
 cblock {
     /* This is raw C code! */
     SV * global = get_sv("global_var", 0);
     sv_setpv(global, "After first cblock");
 }
 
 print "After the first cblock, \$global_var conains [$global_var]\n";

=head1 ALPHA

This project is currently in alpha. Using this software is likely to
cause segmentation faults and the API is likely to change over time.
Basically, if you're not actively developing this code, you should
probably steer clear of it for now.

=head1 DESCRIPTION

This module uses Perl's pluggable keyword API to add a number of new
keywords including C<cblock>, C<cshare>, C<clex>, and C<cuse>.

=over

=item cblock

The C<cblock> keyword is immediately followed by a curly-bracket
delimited block of C code. That code is wrapped into a specially formed
function and compiled at Perl parse time. An OP is then inserted into
the generated OP tree that knows how to call that function whenever
the Perl interpreter reaches this execution point.

=item clex, cshare

The C<clex> and C<cshare> keywords are immediately followed by a
curly-bracket delimited block of C code. That code is compiled at Perl
parse time and the symbol table is made accessible to later C<clex>s,
C<cshare>s, and C<cblock>s in the current lexical scope. In other words,
you can write struct layouts and functions in C<clex> and C<cshare>
blocks that you can later use in C<cblocks>. Furthermore, any code in
C<cshare> blocks is added to the current package's list of shared code
blocks, and the struct definitions, typedefs, macros, function
declarations, and function definitions can be imported into a caller's
lexical scope using C<cuse> (which is likely to be replaced soon, see
below).

=item cuse

The C<cuse> keyword (which is likely to be replaced soon, btw) takes a
package name and pulls in the functionality of any C<cshare> blocks of
code defined in that package. This functionality can then be used in
C<cshare>, C<clex>, and C<cblock> blocks in the current lexical scope.

=back

=head1 DEVELOPMENT BOOTSTRAP

C<C::Blocks> has a somewhat complicated dependency on a version of
L<Alien::TinyCC> that is not yet on CPAN. Since I would like to make it
as easy as possible for others to hack on it and contribute to the
development of the software, I have written functionality into the
F<Build.PL> file that will set up a local copy of the development
version of L<Alien::TinyCC> and build against that. This means that to
get started developing on this library, you simply need to clone the
github repository and run F<Build.PL>:

 git clone https://github.com/run4flat/C-Blocks.git
 cd C-Blocks
 perl Buil.PL

The bootstrap code in F<Build.PL> detects any missing dependencies for
L<Alien::TinyCC> and offers to install them for you. It then builds
L<Alien::TinyCC> in a subfolder of your current directory or installs
the current development copy to your machine if you wish.

=over

Note: the bootstrap restarts itself by calling C<exec>. Strangely, this
seems to cause the very end of the build process to hang on Windows. If
it looks like everything is done on Windows, simply hit C<CTRL-C> to
break out of the deadlock and proceed.

=back


Once everything has been installed, you should be able to proceed with
the normal L<Module::Build> incantation:

 # Linux, Mac        Windows
 ./Build             Build

You should then be able to run tests with code such as

 perl -Mblib t/01-basics.t    # Linux, Mac
 perl -Mblib t\01-basics.t    # Windows

or with C<prove>:

 prove -vb t/01-basics.t    # Linux, Mac
 prove -vb t\01-basics.t    # Windows

You can then hop on to the MagNET's #tinycc channel and join in the
discussion!

=head1 CURRENT STATUS

As of May 26, 2014, the pass/fail matrix is this:

 System \ Test        | 01 | 02 | 03 | 04 | 10 | 12 |
 ----------------------------------------------------
 XP Strawberry 5.18   |  y |  y |  y |  y |  y | #5 |
 Mac perlbrew 5.18 sh |  y |  y |  y |  y | #3 |  y |
 Mac perlbrew 5.18 st |  y |  y |  y | #4 | #3 |  y |
 Wheezy sys 5.14      |  y |  y |  y |  y |  y |  y |

Any failures are enumerated in the table and described below. If
things change, or if you have a new result, please add it to the
table and update the failure descriptions below.

=over

=item 3

On Mac (and possibly Linux), test 10 sometimes displays the following
error:

 Internal error: unable to locate extended symbol

=item 4

On any default-compiled Perlbrew, the generated F<libperl> is a static
library. There is a slim chance that TCC can link against a static
library on Windows and Linux. There is no chance that it can link
against a static library on Mac. Any tests against L<C::Blocks::libperl>
will fail in this situation.

=item 5

On Windows XP running Strawberry Perl v5.18, test #12 segfaults after
the 11th subtest. That subtest is the *second* subtest in which I would
actually manipulate data in an already allocated struct. It appears that
the second time through when actually manipulating things, we get weird
segfaults.

=back

=head2 Old error reports for tests that that now pass

=over

=item 1

On Windows XP running Strawberry Perl 5.18, the very first subtest
of test 04 prints its status:

 ok 1 - Can set Perl data in a cblock using direct function calls

Then Perl crashes.

=item 2

On Windows XP running Strawberry Perl 5.18, for test 10, all cblocks
compile fine, and everything runs fine until I try to execute a
cblock that calls a function that was already called by a previous
cblock. This happens to be the code just after test #14, "sending foo
works". Thereafter, the process crashes.

=item Old 3

On Mac and Linux, test 10 sometimes displays the following error:

 Internal error: unable to locate extended symbol

Other times, it runs the full test suite, passing all but the last
test. for that test, it always reports some odd mish-mashed string,
certainly not the string that I sent it the first time.

=item Old 5

All operating systems appear to segfault with test 12 after the 11th
subtest. That subtest is the *second* subtest in which I would actually
manipulate data in an already allocated struct. It appears that the
second time through when actually manipulating things, we get weird
segfaults.


=back

=head1 GOALS

I have a number of goals I would like to accomplish for this project.

=over

=item Expanded test suite

I have managed to squash many segfaults, and now most tests pass on
most operating systems. I need to push the system with more tests,
including things like typedefs, crazy preprocessor macros, and complex
nested structs.

=item Squash all segfaults

I am still encountering a few of segfaults. I need to figure out what
gives rise to those and plug them.

=item Extended Symbol Table Caching

The current symbol table copying implemented in Alien::TinyCC's copy
of tcc involves an N**2 lookup procedure. For large code bases such
as libperl's, the copy procedure takes on the order of seconds. I
would like to hack on tcc to provide extended symbol table dump and
load functionality to minimize the startup time when using
L<C::Blocks::libperl>.

=item Hash table for extended symbol table lookups

The lookup-by-name is currently implemented by iterating through each
TokenSym and checking if that TokenSym's name matches the bareword of
interest. This could be substantially sped up if I had a hash table
mapping names to TokenSym array offsets.

=item Refactor Blocks.xs

The keyword parser in Blocks.xs is enormous. This needs to be split
into several smaller functions.

=item "Interpolate" sigils

I would like C<$variable> to look up and return the C<SV*>
associated with that variable, either the lexically or the globally
scoped SV. The compiler can be asked at that poin in the parse if
it has seen a lexical variable by that name, so it should be
posible to figure out the correct interpretation (pull from pad
vs pull from symbol table) at C<cblock> compile time.

Furthermore, it shouldn't be too hard to implement. TCC knows how to
detect the C<$> character because it is used in assembly code. I
would like to hack on TCC to treat this like a runtime preprocessor
macro, such that I could write the token stream *during* the C parse
stage. I know enough about token streams to accomplish this.

=item Switch to call_checker and call_parser

The keyword API is so yesterday. I used it for prototyping, but I
need to switch to the new method. That doesn't need to happen before
it hits CPAN, but I would like for it to happen soon.

=item Scrap cuse

I need to come up with a better way of importing code into the
current lexical scope. C<cuse> is doin the job for the moment, but
it kinda sucks and needs to be rethought.

=item Threadsafe

The Tiny C Compiler uses lots of global variables and is therefore not
threadsafe. I would like to contribute back to the project by
encapsulating all of that global state into the compiler state object,
where it belongs. Others in the tcc community have expressed interest in
getting this done, so it is a welcome contribution.

=item Extraction for optimized compiling

Right now the C code gets compiled at Perl's parse time. However, for
code that doesn't change, it would be nice to prototype the code using
C::Blocks, then extract the op-code definitions into an XS file to be
compiled by an optimized compiler (such as gcc). This would require
writing a second pluggable keyword module that takes the same input and
generates XS output instead of compiling the code.

=back

=head1 SEE ALSO

This module uses the Tiny C Compiler through the Alien package provided
by L<Alien::TinyCC>. To learn more about the Tiny C Compiler, see
L<http://bellard.org/tcc/> and L<http://savannah.nongnu.org/projects/tinycc>.

For other ways of compiling C code in your Perl scripts, check out
L<Inline::C>, L<C::TinyCompiler>, and L<XS::TCC>.

=head1 AUTHOR

David Mertens (dcmertens.perl@gmail.com)

=head1 BUGS

Please report any bugs or feature requests for the Alien bindings at the
project's main github page:
L<http://github.com/run4flat/C-Blocks/issues>.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc C::Blocks

You can also look for information at:

=over 4

=item * The Github issue tracker (report bugs here)

L<http://github.com/run4flat/C-Blocks/issues>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/C-Blocks>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/C-Blocks>

=item * Search CPAN

L<http://p3rl.org/C::Blocks>
L<http://search.cpan.org/dist/C-Blocks/>

=back

=head1 ACKNOWLEDGEMENTS

This would not be possible without the amazing Tiny C Compiler or the
Perl pluggable keyword work. My thanks goes out to developers of both of
these amazing pieces of technology.

=head1 LICENSE AND COPYRIGHT

Code copyright 2013 Dickinson College. Documentation copyright 2013 David
Mertens.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut

